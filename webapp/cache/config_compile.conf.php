<?php
// auth-generated by CompileConfigHandler
// date: 01/20/2015 10:56:32
/**
 * Action allows you to separate application and business logic from your
 * presentation. By providing a core set of methods used by the framework,
 * automation in the form of security and validation can occur.
 *
 * @package    Mojavi
 * @subpackage Action
 */
namespace Mojavi\Action;
use Mojavi\Core\MojaviObject;
use Mojavi\Controller\Controller;
use Mojavi\View\View;
use Mojavi\Request\Request;
abstract class Action extends MojaviObject
{
    // +-----------------------------------------------------------------------+
    // | PRIVATE VARIABLES                                                     |
    // +-----------------------------------------------------------------------+
    // +-----------------------------------------------------------------------+
    // | METHODS                                                               |
    // +-----------------------------------------------------------------------+
    /**
     * Execute any application/business logic for this action.
     *
     * @return mixed A string containing the view name associated with this
     *               action.
     *
     *               Or an array with the following indices:
     *
     *               - The parent module of the view that will be executed.
     *               - The view that will be executed.
     */
    abstract function execute ();
    // -------------------------------------------------------------------------
    /**
     * Retrieve the current application context.
     * @return \Mojavi\Core\Context
     */
    public function getContext ()
    {
        return Controller::getInstance()->getContext();
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve the credential required to access this action.
     *
     * @return mixed Data that indicates the level of security for this action.
     */
    public function getCredential ()
    {
        return null;
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve the default view to be executed when a given request is not
     * served by this action.
     *
     * @return mixed A string containing the view name associated with this
     *               action.
     *
     *               Or an array with the following indices:
     *
     *               - The parent module of the view that will be executed.
     *               - The view that will be executed.
     */
    public function getDefaultView ()
    {
        return View::INPUT;
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve the request methods on which this action will process
     * validation and execution.
     *
     * @return int One of the following values:
     *
     *             - Request::GET
     *             - Request::POST
     *             - Request::NONE
     */
    public function getRequestMethods ()
    {
        return Request::GET | Request::POST;
    }
    // -------------------------------------------------------------------------
    /**
     * Execute any post-validation error application logic.
     *
     * @return mixed A string containing the view name associated with this
     *               action.
     *
     *               Or an array with the following indices:
     *
     *               - The parent module of the view that will be executed.
     *               - The view that will be executed.
     */
    public function handleError ()
    {
        return View::ERROR;
    }
    // -------------------------------------------------------------------------
    /**
     * Initialize this action.
     *
     * @param Context The current application context.
     *
     * @return bool true, if initialization completes successfully, otherwise
     *              false.
     */
    public function initialize ($context)
    {
        return true;
    }
    // -------------------------------------------------------------------------
    /**
     * Indicates that this action requires security.
     *
     * @return bool true, if this action requires security, otherwise false.
     */
    public function isSecure ()
    {
        return false;
    }
    // -------------------------------------------------------------------------
    /**
     * Manually register validators for this action.
     * @param ValidatorManager A ValidatorManager instance.
     * @return void
     */
    public function registerValidators ($validatorManager)
    {
    }
    // -------------------------------------------------------------------------
    /**
     * Manually validate files and parameters.
     *
     * @return bool true, if validation completes successfully, otherwise false.
     */
    public function validate ()
    {
        return true;
    }
    /**
     * returns the errors
     * @return \Mojavi\Error\Errors
     */
    function getErrors() {
        return $this->getContext()->getErrors();
    }
}
/**
 * ActionStack keeps a list of all requested actions and provides accessor
 * methods for retrieving individual entries.
 *
 * @package    Mojavi
 * @subpackage Action
 */
namespace Mojavi\Action;
use Mojavi\Core\MojaviObject;
class ActionStack extends MojaviObject
{
    // +-----------------------------------------------------------------------+
    // | PRIVATE VARIABLES                                                     |
    // +-----------------------------------------------------------------------+
    private
        $stack = array();
    // +-----------------------------------------------------------------------+
    // | METHODS                                                               |
    // +-----------------------------------------------------------------------+
    /**
     * Add an entry.
     *
     * @param string A module name.
     * @param string An action name.
     * @param Action An action implementation instance.
     *
     * @return void
     */
    public function addEntry ($moduleName, $actionName, $actionInstance)
    {
        // create our action stack entry and add it to our stack
        $actionEntry = new ActionStackEntry($moduleName, $actionName,
                                            $actionInstance);
        $this->stack[] = $actionEntry;
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve the entry at a specific index.
     *
     * @param int An entry index.
     *
     * @return ActionStackEntry An action stack entry implementation.
     */
    public function getEntry ($index)
    {
        $retval = null;
        if ($index > -1 && $index < count($this->stack))
        {
            $retval = $this->stack[$index];
        }
        return $retval;
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve the first entry.
     *
     * @return ActionStackEntry An action stack entry implementation.
     */
    public function getFirstEntry ()
    {
        $count  = count($this->stack);
        $retval = null;
        if ($count > 0)
        {
            $retval = $this->stack[0];
        }
        return $retval;
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve the last entry.
     *
     * @return ActionStackEntry An action stack entry implementation.
     */
    public function getLastEntry ()
    {
        $count  = count($this->stack);
        $retval = null;
        if ($count > 0)
        {
            $retval = $this->stack[$count - 1];
        }
        return $retval;
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve the size of this stack.
     *
     * @return int The size of this stack.
     */
    public function getSize ()
    {
        return count($this->stack);
    }
}
/**
 * ActionStackEntry represents information relating to a single Action request
 * during a single HTTP request.
 *
 * @package    Mojavi
 * @subpackage Action
 */
namespace Mojavi\Action;
use Mojavi\Core\MojaviObject;
class ActionStackEntry extends MojaviObject
{
    // +-----------------------------------------------------------------------+
    // | PRIVATE VARIABLES                                                     |
    // +-----------------------------------------------------------------------+
    private
        $actionInstance = null,
        $actionName     = null,
        $microtime      = null,
        $moduleName     = null,
        $presentation   = null;
    // +-----------------------------------------------------------------------+
    // | METHODS                                                               |
    // +-----------------------------------------------------------------------+
    /**
     * Class constructor.
     *
     * @param string A module name.
     * @param string An action name.
     * @param Action An action implementation instance.
     *
     * @return void
     */
    public function __construct ($moduleName, $actionName, $actionInstance)
    {
        $this->actionName     = $actionName;
        $this->actionInstance = $actionInstance;
        $this->microtime      = microtime();
        $this->moduleName     = $moduleName;
    }
    /**
     * Retrieve this entry's action name.
     *
     * @return string An action name.
     */
    public function getActionName ()
    {
        return $this->actionName;
    }
    /**
     * Retrieve this entry's action instance.
     *
     * @return Action An action implementation instance.
     */
    public function getActionInstance ()
    {
        return $this->actionInstance;
    }
    /**
     * Retrieve this entry's microtime.
     *
     * @return string A string representing the microtime this entry was
     *                created.
     */
    public function getMicrotime ()
    {
        return $this->microtime;
    }
    /**
     * Retrieve this entry's module name.
     *
     * @return string A module name.
     */
    public function getModuleName ()
    {
        return $this->moduleName;
    }
    /**
     * Retrieve this entry's rendered view presentation.
     *
     * This will only exist if the view has processed and the render mode
     * is set to View::RENDER_VAR.
     *
     * @return string An action name.
     */
    public function & getPresentation ()
    {
        return $this->presentation;
    }
    /**
     * Set the rendered presentation for this action.
     *
     * @param string A rendered presentation.
     *
     * @return void
     */
    public function setPresentation (&$presentation)
    {
        $this->presentation =& $presentation;
    }
}
/**
 * Context provides information about the current application context, such as
 * the module and action names and the module directory. References to the
 * current controller, request, and user implementation instances are also
 * provided.
 *
 * @package    Mojavi
 * @subpackage Core
 */
namespace Mojavi\Core;
class Context extends MojaviObject
{
    // +-----------------------------------------------------------------------+
    // | PRIVATE VARIABLES                                                     |
    // +-----------------------------------------------------------------------+
    private
    $actionStack     = null,
    $controller      = null,
    $databaseManager = null,
    $request         = null,
    $storage         = null,
    $errors          = null,
    $user            = null;
    // +-----------------------------------------------------------------------+
    // | CONSTRUCTOR                                                           |
    // +-----------------------------------------------------------------------+
    /**
     * Class constructor.
     *
     * @param Controller      The current Controller implementation instance.
     * @param WebRequest         The current Request implementation instance.
     * @param User            The current User implementation instance.
     * @param Storage         The current Storage implementation instance.
     * @param DatabaseManager The current DatabaseManager instance.
     */
    public function __construct ($controller, $request, $user, $storage,
    $databaseManager)
    {
        $this->actionStack     = $controller->getActionStack();
        $this->controller      = $controller;
        /* @var $this->databaseManager DatabaseManager */
        $this->databaseManager = $databaseManager;
        $this->request         = $request;
        $this->storage         = $storage;
        $this->user            = $user;
    }
    // +-----------------------------------------------------------------------+
    // | METHODS                                                               |
    // +-----------------------------------------------------------------------+
    /**
     * Retrieve the action name for this context.
     *
     * @return string The currently executing action name, if one is set,
     *                otherwise null.
     */
    public function getActionName ()
    {
        // get the last action stack entry
        $actionEntry = $this->actionStack->getLastEntry();
        return $actionEntry->getActionName();
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve the controller.
     *
     * @return Controller The current Controller implementation instance.
     */
    public function getController ()
    {
        return $this->controller;
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve a database connection from the database manager.
     *
     * This is a shortcut to manually getting a connection from an existing
     * database implementation instance.
     *
     * If the MO_USE_DATABASE setting is off, this will return null.
     *
     * @param name A database name.
     *
     * @return mixed A Database instance.
     *
     * @throws <b>DatabaseException</b> If the requested database name does
     *                                  not exist.
     */
    public function getDatabaseConnection ($name = 'default')
    {
        if ($this->databaseManager != null)
        {
            return $this->databaseManager->getDatabase($name)->getConnection();
        }
        return null;
    }
    /**
     * Alias for database manager's getAllDatabases, returns an array of all database names
     *
     * @return array of strings
     */
    public function getAllDatabases() {
        $retval = null;
        if(!is_null($this->databaseManager)) {
            $retval = $this->databaseManager->getAllDatabases();
        }
        return $retval;
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve the database manager.
     *
     * @return DatabaseManager The current DatabaseManager instance.
     */
    public function getDatabaseManager ()
    {
        return $this->databaseManager;
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve the module directory for this context.
     *
     * @return string An absolute filesystem path to the directory of the
     *                currently executing module, if one is set, otherwise null.
     */
    public function getModuleDirectory ()
    {
        // get the last action stack entry
        $actionEntry = $this->actionStack->getLastEntry();
        return MO_MODULE_DIR . '/' . $actionEntry->getModuleName();
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve the module name for this context.
     *
     * @return string The currently executing module name, if one is set,
     *                otherwise null.
     */
    public function getModuleName ()
    {
        // get the last action stack entry
        $actionEntry = $this->actionStack->getLastEntry();
        return $actionEntry->getModuleName();
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve the request.
     *
     * @return \Mojavi\Request\WebRequest The current Request implementation instance.
     */
    public function getRequest ()
    {
        return $this->request;
    }
    /**
     * Returns the Errors object
     * @return \Mojavi\Error\Errors
     */
    public function getErrors() {
        return $this->getRequest()->getErrors();
    }
    /**
     * Clears the errors object
     * @return void
     */
    public function clearErrors() {
        $this->getRequest()->clearErrors();
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve the storage.
     *
     * @return Storage The current Storage implementation instance.
     */
    public function getStorage ()
    {
        return $this->storage;
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve the user.
     *
     * @return User The current User implementation instance.
     */
    public function getUser ()
    {
        return $this->user;
    }
}
/**
 * Controller directs application flow.
 *
 * @package    Mojavi
 * @subpackage Controller
 */
namespace Mojavi\Controller;
use Mojavi\Exception\RenderException;
use Mojavi\Exception\ForwardException;
use Mojavi\Exception\ConfigurationException;
use Mojavi\Exception\ControllerException;
use Mojavi\Exception\FactoryException;
use Mojavi\Exception\MojaviException;
use Mojavi\Action\ActionStack;
use Mojavi\Database\DatabaseManager;
use Mojavi\Config\ConfigCache;
use Mojavi\Core\MojaviObject;
use Mojavi\Exception\SecurityException;
use Mojavi\User\SecurityUser;
use Mojavi\Filter\ExecutionFilter;
use Mojavi\View\View;
use Exception;
abstract class Controller extends MojaviObject
{
    // +-----------------------------------------------------------------------+
    // | PRIVATE VARIABLES                                                     |
    // +-----------------------------------------------------------------------+
    private
        $actionStack     = null,
        $context         = null,
        $databaseManager = null,
        $maxForwards     = 20,
        $renderMode      = View::RENDER_CLIENT,
        $request         = null,
        $securityFilter  = null,
        $storage         = null,
        $user            = null;
    private static
        $instance = null;
    // +-----------------------------------------------------------------------+
    // | METHODS                                                               |
    // +-----------------------------------------------------------------------+
    /**
     * Indicates whether or not a module has a specific action.
     *
     * @param string A module name.
     * @param string An action name.
     *
     * @return bool true, if the action exists, otherwise false.
     */
    public function actionExists ($moduleName, $actionName)
    {
        $file = MO_MODULE_DIR . '/' . $moduleName . '/actions/' . $actionName .
                'Action.php';
        return is_readable($file);
    }
    // -------------------------------------------------------------------------
    /**
     * Forward the request to another action.
     *
     * @param string A module name.
     * @param string An action name.
     *
     * @return void
     *
     * @throws <b>ConfigurationException</b> If an invalid configuration setting
     *                                       has been found.
     * @throws <b>ForwardException</b> If an error occurs while forwarding the
     *                                 request.
     * @throws <b>InitializationException</b> If the action could not be
     *                                        initialized.
     * @throws <b>SecurityException</b> If the action requires security but
     *                                  the user implementation is not of type
     *                                  SecurityUser.
     */
    public function forward ($moduleName, $actionName)
    {
        // replace periods with slashes for action sub-directories
        $actionName = str_replace('.', '/', $actionName);
        // replace unwanted characters
        $moduleName = preg_replace('/[^a-z0-9\-_]+/i', '', $moduleName);
        $actionName = preg_replace('/[^a-z0-9\-_\/]+/i', '', $actionName);
        // track the requested module so we have access to the data
        $this->request->setAttribute('requested_action', $actionName);
        $this->request->setAttribute('requested_module', $moduleName);
        if ($this->actionStack->getSize() >= $this->maxForwards)
        {
            // let's kill this party before it turns into cpu cycle hell
            $error = 'Too many forwards have been detected for this request';
            throw new ForwardException($error);
        }
        if (!MO_AVAILABLE)
        {
            // application is unavailable
            $moduleName = MO_UNAVAILABLE_MODULE;
            $actionName = MO_UNAVAILABLE_ACTION;
            if (!$this->actionExists($moduleName, $actionName))
            {
                // cannot find unavailable module/action
                $error = 'Invalid configuration settings: ' .
                         'MO_UNAVAILABLE_MODULE "%s", ' .
                         'MO_UNAVAILABLE_ACTION "%s"';
                $error = sprintf($error, $moduleName, $actionName);
                throw new ConfigurationException($error);
            }
        } else if (!$this->actionExists($moduleName, $actionName))
        {
            // the requested action doesn't exist
            // switch to error 404 action
            $moduleName = MO_ERROR_404_MODULE;
            $actionName = MO_ERROR_404_ACTION;
            if (!$this->actionExists($moduleName, $actionName))
            {
                // cannot find unavailable module/action
                $error = 'Invalid configuration settings: ' .
                         'MO_ERROR_404_MODULE "%s", ' .
                         'MO_ERROR_404_ACTION "%s"';
                $error = sprintf($error, $moduleName, $actionName);
                throw new ConfigurationException($error);
            }
        }
        // create an instance of the action
        $actionInstance = $this->getAction($moduleName, $actionName);
        // add a new action stack entry
        $this->actionStack->addEntry($moduleName, $actionName,
                                     $actionInstance);
        // include the module configuration
        ConfigCache::import('modules/' . $moduleName . '/config/module.ini');
        if (constant('MOD_' . strtoupper($moduleName) . '_ENABLED'))
        {
            // module is enabled
            // check for a module config.php
            $moduleConfig = MO_MODULE_DIR . '/' . $moduleName . '/config.php';
            if (is_readable($moduleConfig))
            {
                require_once($moduleConfig);
            }
            // initialize the action
            if ($actionInstance->initialize($this->context))
            {
                // create a new filter chain
                $filterChain = new \Mojavi\Filter\FilterChain();
                if (MO_AVAILABLE)
                {
                    // the application is available so we'll register
                    // global and module filters, otherwise skip them
                    // does this action require security?
                    if (MO_USE_SECURITY && $actionInstance->isSecure())
                    {
                        if (!($this->user instanceof SecurityUser))
                        {
                            // we've got security on but the user implementation
                            // isn't a sub-class of SecurityUser
                            $error = 'Security is enabled, but your User ' .
                                     'implementation isn\'t a sub-class of ' .
                                     'SecurityUser';
                            throw new SecurityException($error);
                        }
                        // register security filter
                        $filterChain->register($this->securityFilter);
                    }
                    // load filters
                    $this->loadGlobalFilters($filterChain);
                    $this->loadModuleFilters($filterChain);
                }
                // register the execution filter
                $execFilter = new ExecutionFilter();
                $execFilter->initialize($this->context);
                $filterChain->register($execFilter);
                // process the filter chain
                $filterChain->execute();
            } else
            {
                // action failed to initialize
                $error = 'Action initialization failed for module "%s", ' .
                         'action "%s"';
                $error = sprintf($error, $moduleName, $actionName);
                throw new \Mojavi\Exception\InitializationException($error);
            }
        } else
        {
            // module is disabled
            $moduleName = MO_MODULE_DISABLED_MODULE;
            $actionName = MO_MODULE_DISABLED_ACTION;
            if (!$this->actionExists($moduleName, $actionName))
            {
                // cannot find mod disabled module/action
                $error = 'Invalid configuration settings: ' .
                         'MO_MODULE_DISABLED_MODULE "%s", ' .
                         'MO_MODULE_DISABLED_ACTION "%s"';
                $error = sprintf($error, $moduleName, $actionName);
                throw new \Mojavi\Exception\ConfigurationException($error);
            }
            $this->forward($moduleName, $actionName);
        }
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve an Action implementation instance.
     *
     * @param string A module name.
     * @param string An action name.
     *
     * @return Action An Action implementation instance, if the action exists,
     *                otherwise null.
     */
    public function getAction ($moduleName, $actionName)
    {
        $file = MO_MODULE_DIR . '/' . $moduleName . '/actions/' . $actionName .
                'Action.php';
        require_once($file);
        $position = strrpos($actionName, '/');
        if ($position > -1)
        {
            $actionName = substr($actionName, $position + 1);
        }
        $class = $actionName . 'Action';
        // fix for same name classes
        $moduleClass = $moduleName . '_' . $class;
        if (class_exists($moduleClass, false))
        {
            $class = $moduleClass;
        }
        return new $class();
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve the action stack.
     *
     * @return ActionStack An ActionStack instance, if the action stack is
     *                     enabled, otherwise null.
     */
    public function getActionStack ()
    {
        return $this->actionStack;
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve the current application context.
     *
     * @return \Mojavi\Core\Context
     */
    public function getContext ()
    {
        return $this->context;
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve the singleton instance of this class.
     *
     * @return Controller A Controller implementation instance.
     *
     * @throws <b>ControllerException</b> If a controller implementation
     *                                    instance has not been created.
     */
    public static function getInstance ()
    {
        if (isset(self::$instance))
        {
            return self::$instance;
        }
        // an instance of the controller has not been created
        $error = 'A Controller implementation instance has not been created';
        throw new ControllerException($error);
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve the presentation rendering mode.
     *
     * @return int One of the following:
     *             - View::RENDER_CLIENT
     *             - View::RENDER_VAR
     */
    public function getRenderMode ()
    {
        return $this->renderMode;
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve a View implementation instance.
     *
     * @param string A module name.
     * @param string A view name.
     *
     * @return View A View implementation instance, if the model exists,
     *              otherwise null.
     */
    public function getView ($moduleName, $viewName)
    {
        $file = MO_MODULE_DIR . '/' . $moduleName . '/views/' . $viewName .
                'View.php';
        require_once($file);
        $position = strrpos($viewName, '/');
        if ($position > -1)
        {
            $viewName = substr($viewName, $position + 1);
        }
        $class = $viewName . 'View';
        // fix for same name classes
        $moduleClass = $moduleName . '_' . $class;
        if (class_exists($moduleClass, false))
        {
            $class = $moduleClass;
        }
        return new $class();
    }
    // -------------------------------------------------------------------------
    /**
     * Initialize this controller.
     *
     * @return void
     */
    protected function initialize ()
    {
        if (MO_USE_DATABASE)
        {
            // setup our database connections
            $this->databaseManager = new DatabaseManager();
            $this->databaseManager->initialize();
        }
        // create a new action stack
        $this->actionStack = new ActionStack();
        // create factory implementation instances
        $config = ConfigCache::checkConfig('config/factories.ini');
        // include the factories configuration
        require_once($config);
        // register our shutdown function
        register_shutdown_function(array($this, 'shutdown'));
        // $this->context is created in the factories configuration up above
        // TODO: logging setup
        // set max forwards
        if (defined('MO_MAX_FORWARDS'))
        {
            $this->maxForwards = MO_MAX_FORWARDS;
        }
    }
    // -------------------------------------------------------------------------
    /**
     * Load global filters.
     *
     * @param FilterChain A FilterChain instance.
     *
     * @return void
     */
    private function loadGlobalFilters ($filterChain)
    {
        static $list = array();
        // grab our global filter ini and preset the module name
        $config     = MO_CONFIG_DIR . '/filters.ini';
        $moduleName = 'global';
        if (!isset($list[$moduleName]) && is_readable($config))
        {
            // load global filters
            require_once(\Mojavi\Config\ConfigCache::checkConfig('config/filters.ini'));
        }
        // register filters
        foreach ($list[$moduleName] as $filter)
        {
            $filterChain->register($filter);
        }
    }
    // -------------------------------------------------------------------------
    /**
     * Load module filters.
     *
     * @param FilterChain A FilterChain instance.
     *
     * @return void
     */
    private function loadModuleFilters ($filterChain)
    {
        // filter list cache file
        static $list = array();
        // get the module name
        $moduleName = $this->context->getModuleName();
        if (!isset($list[$moduleName]))
        {
            // we haven't loaded a filter list for this module yet
            $config = MO_MODULE_DIR . '/' . $moduleName . '/config/filters.ini';
            if (is_readable($config))
            {
                require_once(ConfigCache::checkConfig($config));
            } else
            {
                // add an emptry array for this module since no filters
                // exist
                $list[$moduleName] = array();
            }
        }
        // register filters
        foreach ($list[$moduleName] as $filter)
        {
            $filterChain->register($filter);
        }
    }
    // -------------------------------------------------------------------------
    /**
     * Indicates whether or not a module exists.
     *
     * @param string A module name.
     *
     * @return bool true, if the module exists, otherwise false.
     */
    public function moduleExists ($moduleName)
    {
        $file = MO_MODULE_DIR . '/' . $moduleName . '/config/module.ini';
        return is_readable($file);
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve a new Controller implementation instance.
     *
     * @param string A Controller implementation name.
     *
     * @return Controller A Controller implementation instance.
     *
     * @throws <b>FactoryException</b> If a new controller implementation
     *                                 instance cannot be created.
     */
    public static function newInstance ($class)
    {
        try
        {
            if (!isset(self::$instance))
            {
                // the class exists
                $object = new $class();
                if (!($object instanceof Controller))
                {
                    // the class name is of the wrong type
                    $error = 'Class "%s" is not of the type Controller';
                    $error = sprintf($error, $class);
                    throw new FactoryException($error);
                }
                // set our singleton instance
                self::$instance = $object;
                return $object;
            } else
            {
                $type = get_class(self::$instance);
                // an instance has already been created
                $error = 'A Controller implementation instance has already ' .
                         'been created';
                throw new FactoryException($error);
            }
        } catch (MojaviException $e)
        {
            $e->printStackTrace();
        } catch (Exception $e)
        {
            // most likely an exception from a third-party library
            $e = new MojaviException($e->getMessage());
            $e->printStackTrace();
        }
    }
    // -------------------------------------------------------------------------
    /**
     * Set the presentation rendering mode.
     *
     * @param int A rendering mode.
     *
     * @return void
     *
     * @throws <b>RenderException</b> - If an invalid render mode has been set.
     */
    public function setRenderMode ($mode)
    {
        if ($mode == View::RENDER_CLIENT || $mode == View::RENDER_VAR ||
            $mode == View::RENDER_NONE)
        {
            $this->renderMode = $mode;
            return;
        }
        // invalid rendering mode type
        $error = 'Invalid rendering mode: %s';
        $error = sprintf($error, $mode);
        throw new RenderException($error);
    }
    // -------------------------------------------------------------------------
    /**
     * Execute the shutdown procedure.
     *
     * @return void
     */
    public function shutdown ()
    {
        $this->user->shutdown();
        session_write_close();
        $this->storage->shutdown();
        $this->request->shutdown();
        if (MO_USE_DATABASE)
        {
            $this->databaseManager->shutdown();
        }
    }
    // -------------------------------------------------------------------------
    /**
     * Indicates whether or not a module has a specific view.
     *
     * @param string A module name.
     * @param string A view name.
     *
     * @return bool true, if the view exists, otherwise false.
     */
    public function viewExists ($moduleName, $viewName)
    {
        $file = MO_MODULE_DIR . '/' . $moduleName . '/views/' . $viewName .
                'View.php';
        return is_readable($file);
    }
}
namespace Mojavi\Filter;
use Mojavi\Util\ParameterHolder as ParameterHolder;
use Mojavi\Controller\Controller as Controller;
/**
 * Filter provides a way for you to intercept incoming requests or outgoing
 * responses.
 */
abstract class Filter extends ParameterHolder
{
    // +-----------------------------------------------------------------------+
    // | PRIVATE VARIABLES                                                     |
    // +-----------------------------------------------------------------------+
    // +-----------------------------------------------------------------------+
    // | METHODS                                                               |
    // +-----------------------------------------------------------------------+
    /**
     * Execute this filter.
     *
     * @param FilterChain A FilterChain instance.
     *
     * @return void
     */
    abstract function execute ($filterChain);
    // -------------------------------------------------------------------------
    /**
     * Retrieve the current application context.
     *
     * @return Context The current Context instance.
     */
    public function getContext ()
    {
        return Controller::getInstance()->getContext();
    }
    // -------------------------------------------------------------------------
    /**
     * Initialize this Filter.
     *
     * @param Context The current application context.
     * @param array   An associative array of initialization parameters.
     *
     * @return bool true, if initialization completes successfully, otherwise
     *              false.
     *
     * @throws <b>InitializationException</b> If an error occurs while
     *                                        initializing this Filter.
     */
    public function initialize ($context, $parameters = null)
    {
        if ($parameters != null)
        {
            $this->parameters = array_merge($this->parameters, $parameters);
        }
        return true;
    }
}
namespace Mojavi\Filter;
use Mojavi\Exception\ViewException as ViewException;
use Mojavi\Exception\InitializationException as InitializationException;
use Mojavi\Validator\ValidatorManager as ValidatorManager;
use Mojavi\View\View as View;
use Mojavi\Config\ConfigCache as ConfigCache;
/**
 * ExecutionFilter is the last filter registered for each filter chain. This
 * filter does all action and view execution.
 */
class ExecutionFilter extends Filter
{
    // +-----------------------------------------------------------------------+
    // | METHODS                                                               |
    // +-----------------------------------------------------------------------+
    /**
     * Execute this filter.
     *
     * @param FilterChain The filter chain.
     *
     * @return void
     *
     * @throws <b>InitializeException</b> If an error occurs during view
     *                                    initialization.
     * @throws <b>ViewException</b>       If an error occurs while executing
     *                                    the view.
     */
    public function execute ($filterChain)
    {
        static
            $context,
            $controller,
            $validatorManager;
        if (!isset($context))
        {
            // get the context and controller
            $context    = $this->getContext();
            $controller = $context->getController();
            // create validator manager
            $validatorManager = new ValidatorManager();
            $validatorManager->initialize($context);
        } else
        {
            // clear the validator manager for reuse
            $validatorManager->clear();
        }
        // get the current action instance
        $actionEntry    = $controller->getActionStack()->getLastEntry();
        $actionInstance = $actionEntry->getActionInstance();
        // get the current action information
        $moduleName = $context->getModuleName();
        $actionName = $context->getActionName();
        // get the request method
        $method = $context->getRequest()->getMethod();
        if (($actionInstance->getRequestMethods() & $method) != $method)
        {
            // this action will skip validation/execution for this method
            // get the default view
            $viewName = $actionInstance->getDefaultView();
        } else
        {
            // set default validated status
            $validated = true;
            // get the current action validation configuration
            $validationConfig = MO_MODULE_DIR . '/' . $moduleName .
                                '/validate/' . $actionName . '.ini';
            if (is_readable($validationConfig))
            {
                // load validation configuration
                // do NOT use require_once
                $validationConfig = 'modules/' . $moduleName .
                                    '/validate/' . $actionName . '.ini';
                require(ConfigCache::checkConfig($validationConfig));
            }
            // manually load validators
            $actionInstance->registerValidators($validatorManager);
            // process validators
            $validated = $validatorManager->execute();
            // process manual validation
            if ($validated && $actionInstance->validate())
            {
                // execute the action
                $viewName = $actionInstance->execute();
            } else
            {
                // validation failed
                $viewName = $actionInstance->handleError();
            }
        }
        if ($viewName != View::NONE)
        {
            if (is_array($viewName))
            {
                // we're going to use an entirely different action for this view
                $moduleName = $viewName[0];
                $viewName   = $viewName[1];
            } else
            {
                // use a view related to this action
                $viewName = $actionName . $viewName;
            }
            // display this view
            if (!$controller->viewExists($moduleName, $viewName))
            {
                // the requested view doesn't exist
                $file = MO_MODULE_DIR . '/' . $moduleName . '/views/' .
                        $viewName . 'View.php';
                $error = 'Module "%s" does not contain the view "%sView" or ' .
                         'the file "%s" is unreadable';
                $error = sprintf($error, $moduleName, $viewName, $file);
                throw new ViewException($error);
            }
            // get the view instance
            $viewInstance = $controller->getView($moduleName, $viewName);
            // initialize the view
            if ($viewInstance->initialize($context))
            {
                // view initialization completed successfully
                $viewInstance->execute();
                // render the view and if data is returned, stick it in the
                // action entry which was retrieved from the execution chain
                $viewData =& $viewInstance->render();
                if ($controller->getRenderMode() == View::RENDER_VAR)
                {
                    $actionEntry->setPresentation($viewData);
                }
            } else
            {
                // view failed to initialize
                $error = 'View initialization failed for module "%s", ' .
                         'view "%sView"';
                $error = sprintf($error, $moduleName, $viewName);
                throw new InitializationException($error);
            }
        }
    }
}
namespace Mojavi\Filter;
use Mojavi\Core\MojaviObject as MojaviObject;
/**
 * FilterChain manages registered filters for a specific context.
 */
class FilterChain extends MojaviObject
{
    // +-----------------------------------------------------------------------+
    // | PRIVATE VARIABLES                                                     |
    // +-----------------------------------------------------------------------+
    private
        $chain = array(),
        $index = -1;
    // +-----------------------------------------------------------------------+
    // | METHODS                                                               |
    // +-----------------------------------------------------------------------+
    /**
     * Execute the next filter in this chain.
     *
     * @return void
     */
    public function execute ()
    {
        // skip to the next filter
        $this->index++;
        if ($this->index < count($this->chain))
        {
            // execute the next filter
            $this->chain[$this->index]->execute($this);
        }
    }
    // -------------------------------------------------------------------------
    /**
     * Register a filter with this chain.
     *
     * @param Filter A Filter implementation instance.
     *
     * @return void
     */
    public function register ($filter)
    {
        $this->chain[] = $filter;
    }
}
namespace Mojavi\Logging;
// +---------------------------------------------------------------------------+
// | This file is part of the Agavi package.                                   |
// | Copyright (c) 2003-2005 Agavi Foundation.                                 |
// |                                                                           |
// | For the full copyright and license information, please view the LICENSE   |
// | file that was distributed with this source code. You can also view the    |
// | LICENSE file online at http://www.agavi.org/LICENSE.txt                   |
// |   vi: set noexpandtab:                                                    |
// |   Local Variables:                                                        |
// |   indent-tabs-mode: t                                                     |
// |   End:                                                                    |
// +---------------------------------------------------------------------------+
/**
 * Appender allows you to specify a destination for log data and provide
 * a custom layout for it, through which all log messages will be formatted.
 */
abstract class Appender extends \Mojavi\Core\MojaviObject
{
    private $layout = null;
    private $priority = null;
    /**
     * Initialize the object.
     *
     * @return void
     */
    abstract function initialize($params);
    // -------------------------------------------------------------------------
    /**
     * Retrieve the layout.
     *
     * @return Layout A Layout instance, if one has been set, otherwise null.
     */
    public function getLayout ()
    {
        return $this->layout;
    }
    // -------------------------------------------------------------------------
    /**
     * Set the layout.
     *
     * @param Layout A Layout instance.
     *
     * @return Appender
     */
    public function setLayout ($layout)
    {
        $this->layout = $layout;
        return $this;
    }
    // -------------------------------------------------------------------------
    /**
     * Execute the shutdown procedure.
     *
     * @return void
     */
    abstract function shutdown ();
    // -------------------------------------------------------------------------
    /**
     * returns the priority
     * @return string
     */
    function getPriority() {
        if (is_null($this->priority)) {
            $this->priority = Logger::INFO;
        }
        return $this->priority;
    }
    /**
     * sets the priority
     * @param string $arg0
     */
    function setPriority($arg0) {
        $this->priority = $arg0;
    }
    /**
     * Write log data to this appender.
     *
     * @param string Log data to be written.
     *
     * @return void
     */
    abstract function write ($message);
}
namespace Mojavi\Logging;
// +---------------------------------------------------------------------------+
// | This file is part of the Agavi package.                                   |
// | Copyright (c) 2003-2005 Agavi Foundation.                                 |
// |                                                                           |
// | For the full copyright and license information, please view the LICENSE   |
// | file that was distributed with this source code. You can also view the    |
// | LICENSE file online at http://www.agavi.org/LICENSE.txt                   |
// |   vi: set noexpandtab:                                                    |
// |   Local Variables:                                                        |
// |   indent-tabs-mode: t                                                     |
// |   End:                                                                    |
// +---------------------------------------------------------------------------+
/**
 * Layout allows you to specify a message layout for log messages.
 */
abstract class Layout extends \Mojavi\Core\MojaviObject
{
    private $layout = null;
    /**
     * Initialize the Layout.
     *
     * @access public
     * @param array An array of parameters.
     * @return void
     */
    public function initialize($params)
    {
        /* empty so we're not required to override this */
    }
    /**
     * Format a message.
     *
     * @param Message A Message instance.
     *
     * @return string A formatted message.
     */
    abstract function & format ($message);
    // -------------------------------------------------------------------------
    /**
     * Retrieve the message layout.
     *
     * @return string A message layout.
     */
    public function getLayout ()
    {
        return $this->layout;
    }
    // -------------------------------------------------------------------------
    /**
     * Set the message layout.
     *
     * @param string A message layout.
     *
     * @return void
     */
    public function setLayout ($layout)
    {
        $this->layout = $layout;
    }
}
namespace Mojavi\Logging;
use Mojavi\Exception\LoggingException as LoggingException;
// +---------------------------------------------------------------------------+
// | This file is part of the Agavi package.                                   |
// | Copyright (c) 2003-2005 Agavi Foundation.                                 |
// |                                                                           |
// | For the full copyright and license information, please view the LICENSE   |
// | file that was distributed with this source code. You can also view the    |
// | LICENSE file online at http://www.agavi.org/LICENSE.txt                   |
// |   vi: set noexpandtab:                                                    |
// |   Local Variables:                                                        |
// |   indent-tabs-mode: t                                                     |
// |   End:                                                                    |
// +---------------------------------------------------------------------------+
/**
 * Logger provides an easy way to manage multiple log destinations and write
 * to them all simultaneously.
 */
class Logger extends \Mojavi\Core\MojaviObject
{
    /**
     * Debug level.
     *
     * @since 0.9.0
     */
    const DEBUG = 1000;
    /**
     * Error level.
     *
     * @since 0.9.0
     */
    const ERROR = 4000;
    /**
     * Information level.
     *
     * @since 0.9.0
     */
    const INFO = 2000;
    /**
     * Warning level.
     *
     * @since 0.9.0
     */
    const WARN = 3000;
    /**
     * Fatal level.
     *
     * @since 0.9.0
     */
    const FATAL = 5000;
    private
        $appenders    = array(),
        $priority     = null;
    /**
     * Constructor.
     *
     * @return void
     */
    public function __construct()
    {
        $this->priority = self::WARN;
    }
    // -------------------------------------------------------------------------
    /**
     * Log a message.
     *
     * @param Message A Message instance.
     *
     * @return void
     */
    public function log (Message $message)
    {
        // get message priority
        $msgPriority = $message->getPriority();
        if ($msgPriority >= $this->priority || $this->priority < 1)
        {
            foreach ($this->appenders as $appender)
            {
                if ($msgPriority >= $appender->getPriority()) {
                    $appender->write($message);
                }
            }
        }
    }
    // -------------------------------------------------------------------------
    /**
     * Set an appender.
     *
     * If an appender with the name already exists, an exception will be thrown.
     *
     * @param string   An appender name.
     * @param Appender An Appender instance.
     *
     * @return void
     *
     * @throws <b>LoggingException</b> If an appender with the name already
     *                                 exists.
     */
    public function setAppender ($name, $appender)
    {
        if (!isset($this->appenders[$name]))
        {
            $this->appenders[$name] = $appender;
            return;
        }
        // appender already exists
        $error = 'An appender with the name "%s" is already registered';
        $error = sprintf($error, $name);
        throw new LoggingException($error);
    }
    // -------------------------------------------------------------------------
    /**
     * Set the priority level.
     *
     * @param int A priority level.
     *
     * @return void
     */
    public function setPriority ($priority)
    {
        $this->priority = $priority;
    }
    // -------------------------------------------------------------------------
    /**
     * Execute the shutdown procedure.
     *
     * @return void
     */
    public function shutdown ()
    {
        // loop through our appenders and shut them all down
        foreach ($this->appenders as $appender)
        {
            $appender->shutdown();
        }
    }
}
namespace Mojavi\Logging;
/**
 * ErrorLogger
 */
class ErrorLogger extends Logger
{
    // +-----------------------------------------------------------------------+
    // | CONSTANTS                                                             |
    // +-----------------------------------------------------------------------+
    // +-----------------------------------------------------------------------+
    // | PUBLIC VARIABLES                                                      |
    // +-----------------------------------------------------------------------+
    // +-----------------------------------------------------------------------+
    // | PRIVATE VARIABLES                                                     |
    // +-----------------------------------------------------------------------+
    // +-----------------------------------------------------------------------+
    // | CONSTRUCTOR                                                           |
    // +-----------------------------------------------------------------------+
    // +-----------------------------------------------------------------------+
    // | METHODS                                                               |
    // +-----------------------------------------------------------------------+
}
namespace Mojavi\Logging;
use Mojavi\Core\MojaviObject as MojaviObject;
use Mojavi\Exception\LoggingException as LoggingException;
use Mojavi\Config\ConfigCache as ConfigCache;
// +---------------------------------------------------------------------------+
// | This file is part of the Agavi package.                                   |
// | Copyright (c) 2003-2005 Agavi Foundation.                                 |
// |                                                                           |
// | For the full copyright and license information, please view the LICENSE   |
// | file that was distributed with this source code. You can also view the    |
// | LICENSE file online at http://www.agavi.org/LICENSE.txt                   |
// |   vi: set noexpandtab:                                                    |
// |   Local Variables:                                                        |
// |   indent-tabs-mode: t                                                     |
// |   End:                                                                    |
// +---------------------------------------------------------------------------+
/**
 * LoggerManager provides accessibility and management of all loggers.
 */
class LoggerManager extends MojaviObject
{
    private static $loggers = array();
    /**
     * Initialize this LoggingManager.
     *
     * @return bool true, if initialization completes successfully, otherwise
     *              false.
     *
     * @throws <b>InitializationException</b> If an error occurs while
     *                                        initializing this LoggingManager.
     */
    public static function initialize ()
    {
        // load database configuration
        require_once(ConfigCache::checkConfig('config/logging.ini'));
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve a logger.
     *
     * @param string A logger name.
     *
     * @return Logger A Logger, if a logger with the name exists, otherwise
     *                null.
     */
    public static function getLogger ($name = 'default')
    {
        if (isset(self::$loggers[$name]))
        {
            return self::$loggers[$name];
        }
        return null;
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve a list of logger names.
     *
     * @return array An indexed array of logger names.
     */
    public static function getLoggerNames ()
    {
        return array_keys(self::$loggers);
    }
    // -------------------------------------------------------------------------
    /**
     * Indicates that a logger exists.
     *
     * @param string A logger name.
     *
     * @return bool true, if the logger exists, otherwise false.
     */
    public static function hasLogger ($name)
    {
        return isset(self::$loggers[$name]);
    }
    // -------------------------------------------------------------------------
    /**
     * Remove a logger.
     *
     * @param string A logger name.
     *
     * @return Logger A Logger, if the logger has been removed, otherwise null.
     *
     * @throws <b>LoggingException</b> If the logger name is 'default', which
     *                                 cannot be removed.
     */
    public static function & removeLogger ($name)
    {
        $retval = null;
        if (isset(self::$loggers[$name]))
        {
            if ($name != 'default')
            {
                $retval = self::$loggers[$name];
                unset(self::$loggers[$name]);
            } else
            {
                // cannot remove the default logger
                $error = 'Cannot remove the default logger';
                throw new LoggingException($error);
            }
        }
        return $retval;
    }
    // -------------------------------------------------------------------------
    /**
     * Set a new logger instance.
     *
     * If a logger with the name already exists, an exception will be thrown.
     *
     * @param string A logger name.
     * @param Logger A Logger instance.
     *
     * @return void
     *
     * @throws <b>LoggingException</b> If a logger with the name already exists.
     */
    public static function setLogger ($name, $logger)
    {
        if (!isset(self::$loggers[$name]))
        {
            self::$loggers[$name] = $logger;
            return;
        }
        // logger already exists
        $error = 'A logger with the name "%s" is already registered';
        $error = sprintf($error, $name);
        throw new LoggingException($error);
    }
    // -------------------------------------------------------------------------
    /**
     * Log a Message.
     *
     * @param Message The Message to log.
     * @param string Optional logger to log to.
     *
     * @return void
     * @throws LoggingException if the logger was not found.
     */
    public static function log(Message $message, $logger = null)
    {
        if (is_null($logger)) {
            if (count(self::$loggers) == 0) {
                LoggerManager::initialize();
            }
            foreach (self::$loggers as $key => $logger) {
                $logger->log($message);
            }
        } else if (!is_null($logger = self::getLogger($logger))) {
            $logger->log($message);
        } else {
            throw new LoggingException("{$logger} Logger is not configured.");
        }
    }
    // -------------------------------------------------------------------------
    /**
     * Execute the shutdown procedure.
     *
     * @return void
     */
    public static function shutdown ()
    {
        // loop through our loggers and shut them all down
        foreach (self::$loggers as $name => $logger)
        {
            $logger->shutdown();
            unset(self::$loggers[$name]);
        }
    }
    /**
    * logs an error message with priority of Logger::ERROR
    *
    * @param string A string message
    *
    * @return void
    *
    * @since  0.9.0
    */
    public static function error($message) {
        LoggerManager::log(new Message($message, Logger::ERROR));
    }
    /**
    * logs an error message with priority of Logger::ERROR
    *
    * @param string A string message
    *
    * @return void
    *
    * @since  0.9.0
    */
    public static function warn($message) {
        LoggerManager::log(new Message($message, Logger::WARN));
    }
    /**
    * logs an error message with priority of Logger::ERROR
    *
    * @param string A string message
    *
    * @return void
    *
    * @since  0.9.0
    */
    public static function info($message) {
        LoggerManager::log(new Message($message, Logger::INFO));
    }
    /**
    * logs an error message with priority of Logger::ERROR
    *
    * @param string A string message
    *
    * @return void
    *
    * @since  0.9.0
    */
    public static function debug($message) {
        LoggerManager::log(new Message($message, Logger::DEBUG));
    }
    /**
    * logs an error message with priority of Logger::ERROR
    *
    * @param string A string message
    *
    * @return void
    *
    * @since  0.9.0
    */
    public static function fatal($message) {
        LoggerManager::log(new Message($message, Logger::FATAL));
    }
}
namespace Mojavi\Logging;
// +---------------------------------------------------------------------------+
// | This file is part of the Agavi package.                                   |
// | Copyright (c) 2003-2005 Agavi Foundation.                                 |
// |                                                                           |
// | For the full copyright and license information, please view the LICENSE   |
// | file that was distributed with this source code. You can also view the    |
// | LICENSE file online at http://www.agavi.org/LICENSE.txt                   |
// |   vi: set noexpandtab:                                                    |
// |   Local Variables:                                                        |
// |   indent-tabs-mode: t                                                     |
// |   End:                                                                    |
// +---------------------------------------------------------------------------+
/**
 * Message, by default, holds a message and a priority level.  It is intended
 * to be passed to a Logger.
 */
class Message extends \Mojavi\Util\ParameterHolder
{
    /**
     * Constructor.
     *
     * @param $message optional message
     * @param $priority optional priority level
     */
    public function __construct($message = null, $priority = Logger::INFO)
    {
        $this->setParameter('m', $message);
        $this->setParameter('p', $priority);
    }
    /**
     * Log this Message.
     *
     * Convenience function to log this Message.
     */
    public function log()
    {
        LoggerManager::log($this);
    }
    /**
     * toString method.
     *
     * @return string
     */
    public function __toString()
    {
        $retVal = "";
        if (is_array($this->getParameter('m'))) {
            $retVal = implode("\n", $this->getParameter('m'));
        } else {
            $retVal = (string) $this->getParameter('m');
        }
        return $retVal;
    }
    /**
     * Set the message.
     *
     * @param $message required
     *
     * @return Message
     */
    public function setMessage($message)
    {
        $this->setParameter('m', $message);
        return $this;
    }
    /**
     * Append to the message.
     *
     * @param $message required
     *
     * @return Message
     */
    public function appendMessage($message)
    {
        $this->appendParameter('m', $message);
        return $this;
    }
    /**
     * Set the priority.
     *
     * @param $priority required
     *
     * @return Message
     */
    public function setPriority($priority)
    {
        $this->setParameter('p', $priority);
        return $this;
    }
    /**
     * Get the priority.
     *
     * @return mixed
     */
    public function getPriority()
    {
        return $this->getParameter('p');
    }
    /**
     * Get the message.
     *
     * @return mixed
     */
    public function getMessage()
    {
        return $this->getParameter('m');
    }
}
namespace Mojavi\Logging;
/**
 * PatternLayout
 */
class PatternLayout extends Layout
{
    // +-----------------------------------------------------------------------+
    // | METHODS                                                               |
    // +-----------------------------------------------------------------------+
    /**
     * Format a message.
     *
     * @param Message A Message instance.
     *
     * @return string A formatted message.
     */
    public function & format ($message)
    {
        $msgString = sprintf('%s', $message->__toString());
        return $msgString;
    }
}
/**
 * Request provides methods for manipulating client request information such
 * as attributes, errors and parameters. It is also possible to manipulate the
 * request method originally sent by the user.
 *
 * @package    Mojavi
 * @subpackage Request
 */
namespace Mojavi\Request;
use Mojavi\Util\ParameterHolder as ParameterHolder;
use Mojavi\Controller\Controller as Controller;
use Mojavi\Error\Errors as Errors;
use Mojavi\Error\Error as Error;
use Mojavi\Exception\MojaviException as MojaviException;
use Mojavi\Exception\FactoryException as FactoryException;
abstract class Request extends ParameterHolder
{
    // +-----------------------------------------------------------------------+
    // | CONSTANTS                                                             |
    // +-----------------------------------------------------------------------+
    /**
     * Process validation and execution for only GET requests.
     *
     * @since 3.0.0
     */
    const GET = 2;
    /**
     * Skip validation and execution for any request method.
     *
     * @since 3.0.0
     */
    const NONE = 1;
    /**
     * Process validation and execution for only POST requests.
     *
     * @since 3.0.0
     */
    const POST = 4;
    /**
     * Process validation and execution for only PUT requests.
     *
     * @since 3.0.0
     */
    const PUT = 8;
    /**
     * Process validation and execution for only DELETE requests.
     *
     * @since 3.0.0
     */
    const DELETE = 16;
    /**
     * Allows any request method
     */
    const ANY = 32;
    // +-----------------------------------------------------------------------+
    // | PRIVATE VARIABLES                                                     |
    // +-----------------------------------------------------------------------+
    private
        $attributes = array(),
        $errors     = null,
        $method     = null,
        $rawBody    = null;
    // +-----------------------------------------------------------------------+
    // | METHODS                                                               |
    // +-----------------------------------------------------------------------+
    /**
     * Clear all attributes associated with this request.
     *
     * @return void
     */
    public function clearAttributes ()
    {
        $this->attributes = null;
        $this->attributes = array();
    }
    // -------------------------------------------------------------------------
    /**
     * Extract parameter values from the request.
     *
     * @param array An indexed array of parameter names to extract.
     *
     * @return array An associative array of parameters and their values. If
     *               a specified parameter doesn't exist an empty string will
     *               be returned for its value.
     */
    public function & extractParameters ($names)
    {
        $array = array();
        foreach ($this->parameters as $key => &$value)
        {
            if (in_array($key, $names))
            {
                $array[$key] =& $value;
            }
        }
        return $array;
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve an attribute.
     *
     * @param string An attribute name.
     * @param mixed The name of the module of the form you'd like returned OR the actual value you'd like returned if the parameter does not exist
     * @param string The name of the form you'd like returned
     *
     * @return mixed An attribute value, if the attribute exists, otherwise
     *               null.
     */
    public function & getAttribute ($name, $default = null, $default2 = null)
    {
        $retval = $default;
        if (isset($this->attributes[$name])) {
            $retval = $this->attributes[$name];
        } elseif(!is_null($default2)) {
            $retval = Controller::getInstance()->getContext()->getController()->getForm($default,$default2);
        }
        return $retval;
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve an array of attribute names.
     *
     * @return array An indexed array of attribute names.
     */
    public function getAttributeNames ()
    {
        return array_keys($this->attributes);
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve an error message.
     *
     * @param string An error name.
     *
     * @return string An error message, if the error exists, otherwise null.
     */
    public function getError ($name)
    {
        $retval = null;
        $error_arr = $this->getErrors()->getErrors($name);
        if(isset($error_arr[0])) {
            $retval = $error_arr[0]->getMessage();
        }
        return $retval;
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve an array of error names.
     *
     * @return array An indexed array of error names.
     */
    public function getErrorNames ()
    {
        return $this->getErrors()->getErrorKeys();
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve the errors object
     * @return \Mojavi\Error\Errors
     */
    public function getErrors ()
    {
        if (is_null($this->errors)) {
            $this->errors = new Errors();
        }
        return $this->errors;
    }
    // -------------------------------------------------------------------------
    /**
     * Clears the errors object of all errors
     * @return void
     */
    public function clearErrors ()
    {
        $this->errors = null;
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve this request's method.
     *
     * @return int One of the following constants:
     *             - Request::GET
     *             - Request::POST
     */
    public function getMethod ()
    {
        return $this->method;
    }
    // -------------------------------------------------------------------------
    /**
     * Indicates whether or not an attribute exists.
     *
     * @param string An attribute name.
     *
     * @return bool true, if the attribute exists, otherwise false.
     */
    public function hasAttribute ($name)
    {
        return isset($this->attributes[$name]);
    }
    // -------------------------------------------------------------------------
    /**
     * Indicates whether or not an error exists.
     *
     * @param string An error name.
     *
     * @return bool true, if the error exists, otherwise false.
     */
    public function hasError ($name)
    {
        $error_arr = $this->getErrors()->getErrors($name);
        if(count($error_arr > 0)) {
            return true;
        } else {
            return false;
        }
    }
    // -------------------------------------------------------------------------
    /**
     * Indicates whether or not any errors exist.
     *
     * @return bool true, if any error exist, otherwise false.
     */
    public function hasErrors ()
    {
        if($this->getErrors()->isEmpty()) {
            return false;
        } else {
            return true;
        }
    }
    // -------------------------------------------------------------------------
    /**
     * Initialize this Request.
     *
     * @param Context A Context instance.
     * @param array   An associative array of initialization parameters.
     *
     * @return bool true, if initialization completes successfully, otherwise
     *              false.
     *
     * @throws <b>InitializationException</b> If an error occurs while
     *                                        initializing this Request.
     */
    abstract function initialize ($context, $parameters = null);
    // -------------------------------------------------------------------------
    /**
     * Retrieve a new Request implementation instance.
     *
     * @param string A Request implementation name.
     *
     * @return Request A Request implementation instance.
     *
     * @throws <b>FactoryException</b> If a request implementation instance
     *                                 cannot be created.
     */
    public static function newInstance ($class)
    {
        // the class exists
        $object = new $class();
        if (!($object instanceof Request))
        {
            // the class name is of the wrong type
            $error = 'Class "%s" is not of the type Request';
            $error = sprintf($error, $class);
            throw new FactoryException($error);
        }
        return $object;
    }
    // -------------------------------------------------------------------------
    /**
     * Remove an attribute.
     *
     * @param string An attribute name.
     *
     * @return mixed An attribute value, if the attribute was removed,
     *               otherwise null.
     */
    public function & removeAttribute ($name)
    {
        $retval = null;
        if (isset($this->attributes[$name]))
        {
            $retval =& $this->attributes[$name];
            unset($this->attributes[$name]);
        }
        return $retval;
    }
    // -------------------------------------------------------------------------
    /**
     * Remove an error.
     *
     * @param string An error name.
     *
     * @return string An error message, if the error was removed, otherwise
     *                null.
     */
    public function & removeError ($name)
    {
        $retval = null;
        $error_arr = $this->getErrors()->getErrors($name);
        if(count($error_arr) > 0) {
            $retval = '';
            foreach($error_arr as $error) {
                $retVal .= $error->getMessage() . " ";
            }
        }
        $this->getErrors()->removeErrorsByKey($name);
        return $retval;
    }
    // -------------------------------------------------------------------------
    /**
     * Set an attribute.
     *
     * If an attribute with the name already exists the value will be
     * overridden.
     *
     * @param string An attribute name.
     * @param mixed  An attribute value.
     *
     * @return void
     */
    public function setAttribute ($name, $value)
    {
        $this->attributes[$name] = $value;
    }
    // -------------------------------------------------------------------------
    /**
     * Set an attribute by reference.
     *
     * If an attribute with the name already exists the value will be
     * overridden.
     *
     * @param string An attribute name.
     * @param mixed  A reference to an attribute value.
     *
     * @return void
     */
    public function setAttributeByRef ($name, &$value)
    {
        $this->attributes[$name] =& $value;
    }
    // -------------------------------------------------------------------------
    /**
     * Set an array of attributes.
     *
     * If an existing attribute name matches any of the keys in the supplied
     * array, the associated value will be overridden.
     *
     * @param array An associative array of attributes and their associated
     *              values.
     *
     * @return void
     */
    public function setAttributes ($attributes)
    {
        $this->attributes = array_merge($this->attributes, $attributes);
    }
    // -------------------------------------------------------------------------
    /**
     * Set an array of attributes by reference.
     *
     * If an existing attribute name matches any of the keys in the supplied
     * array, the associated value will be overridden.
     *
     * @param array An associative array of attributes and references to their
     *              associated values.
     *
     * @return void
     */
    public function setAttributesByRef (&$attributes)
    {
        foreach ($attributes as $key => &$value)
        {
            $this->attributes[$key] =& $value;
        }
    }
    // -------------------------------------------------------------------------
    /**
     * Set an error.
     *
     * @param name    An error name.
     * @param message An error message.
     *
     * @return void
     */
    public function setError ($name, $message)
    {
        $this->getErrors()->addError($name, new Error($message));
    }
    // -------------------------------------------------------------------------
    /**
     * Set an array of errors
     *
     * If an existing error name matches any of the keys in the supplied
     * array, the associated message will be overridden.
     *
     * @param array An associative array of errors and their associated
     *              messages.
     *
     * @return void
     */
    public function setErrors ($errors)
    {
        if(is_array($errors)) {
            foreach($errors as $name => $message) {
                $this->getErrors()->addError($name, new Error($message));
            }
        }
    }
    // -------------------------------------------------------------------------
    /**
     * Set the request method.
     *
     * @param int One of the following constants:
     *            - Request::GET
     *            - Request::POST
     *               - Request::PUT
     *               - Request::DELETE
     *
     * @return void
     *
     * @throws <b>MojaviException</b> - If the specified request method is
     *                                  invalid.
     */
    public function setMethod ($method)
    {
        if ($method == self::GET || $method == self::POST || $method == self::PUT || $method == self::DELETE)
        {
            $this->method = $method;
            return;
        }
        // invalid method type
        $error = 'Invalid request method: %s';
        $error = sprintf($error, $method);
        throw new MojaviException($error);
    }
    /**
     * Return the raw body of the request, if present
     *
     * @return string|false Raw body, or false if not present
     */
    public function getRawBody()
    {
        if ($this->rawBody == null) {
            $body = file_get_contents('php://input');
            if (strlen(trim($body)) > 0) {
                $this->rawBody = $body;
            } else {
                $this->rawBody = false;
            }
        }
        return $this->rawBody;
    }
    /**
     * Sets the raw body of the request, if present
     * @return Request
     */
    public function setRawBody($arg0) {
        $this->rawBody = $arg0;
        return $this;
    }
    // -------------------------------------------------------------------------
    /**
     * Execute the shutdown procedure.
     *
     * @return void
     */
    abstract function shutdown ();
}
/**
 * Storage allows you to customize the way Mojavi stores its persistent data.
 *
 * @package    Mojavi
 * @subpackage Storage
 */
namespace Mojavi\Storage;
use Mojavi\Controller\Controller as Controller;
use Mojavi\Util\ParameterHolder as ParameterHolder;
use Mojavi\Exception\FactoryException as FactoryException;
abstract class Storage extends ParameterHolder
{
    // +-----------------------------------------------------------------------+
    // | PRIVATE DATA                                                          |
    // +-----------------------------------------------------------------------+
    // +-----------------------------------------------------------------------+
    // | METHODS                                                               |
    // +-----------------------------------------------------------------------+
    /**
     * Retrieve the current application context.
     *
     * @return Context A Context instance.
     */
    public function getContext ()
    {
        return Controller::getInstance()->getContext();
    }
    // -------------------------------------------------------------------------
    /**
     * Initialize this Storage.
     *
     * @param Context A Context instance.
     * @param array   An associative array of initialization parameters.
     *
     * @return bool true, if initialization completes successfully, otherwise
     *              false.
     *
     * @throws <b>InitializationException</b> If an error occurs while
     *                                        initializing this Storage.
     */
    public function initialize ($context, $parameters = null)
    {
        if ($parameters != null)
        {
            $this->parameters = array_merge($this->parameters, $parameters);
        }
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve a new Storage implementation instance.
     *
     * @param string A Storage implementation name
     *
     * @return Storage A Storage implementation instance.
     *
     * @throws <b>FactoryException</b> If a storage implementation instance
     *                                 cannot be created.
     */
    public static function newInstance ($class)
    {
        // the class exists
        $object = new $class();
        if (!($object instanceof Storage))
        {
            // the class name is of the wrong type
            $error = 'Class "%s" is not of the type Storage';
            $error = sprintf($error, $class);
            throw new FactoryException($error);
        }
        return $object;
    }
    // -------------------------------------------------------------------------
    /**
     * Read data from this storage.
     *
     * The preferred format for a key is directory style so naming conflicts can
     * be avoided.
     *
     * @param string A unique key identifying your data.
     *
     * @return mixed Data associated with the key.
     *
     * @throws <b>StorageException</b> If an error occurs while reading data from
     *                                 this storage.
     */
    abstract function & read ($key);
    // -------------------------------------------------------------------------
    /**
     * Remove data from this storage.
     *
     * The preferred format for a key is directory style so naming conflicts can
     * be avoided.
     *
     * @param string A unique key identifying your data.
     *
     * @return mixed Data associated with the key.
     *
     * @throws <b>StorageException</b> If an error occurs while removing data from
     *                                 this storage.
     */
    abstract function & remove ($key);
    // -------------------------------------------------------------------------
    /**
     * Execute the shutdown procedure.
     *
     * @return void
     *
     * @throws <b>StorageException</b> If an error occurs while shutting down
     *                                 this storage.
     */
    abstract function shutdown ();
    // -------------------------------------------------------------------------
    /**
     * Write data to this storage.
     *
     * The preferred format for a key is directory style so naming conflicts can
     * be avoided.
     *
     * @param string A unique key identifying your data.
     * @param mixed  Data associated with your key.
     *
     * @return void
     *
     * @throws <b>StorageException</b> If an error occurs while writing to this
     *                                 storage.
     */
    abstract function write ($key, &$data);
}
namespace Mojavi\User;
use Mojavi\Util\ParameterHolder as ParameterHolder;
use Mojavi\Exception\FactoryException as FactoryException;
use Mojavi\Controller\Controller as Controller;
/**
 * User wraps a client session and provides accessor methods for user
 * attributes. It also makes storing and retrieving multiple page form data
 * rather easy by allowing user attributes to be stored in namespaces, which
 * help organize data.
 */
class User extends ParameterHolder
{
    // +-----------------------------------------------------------------------+
    // | CONSTANTS                                                             |
    // +-----------------------------------------------------------------------+
    /**
     * The namespace under which attributes will be stored.
     *
     * @since 3.0.0
     */
    const ATTRIBUTE_NAMESPACE = 'org/mojavi/user/User/attributes';
    // +-----------------------------------------------------------------------+
    // | PRIVATE VARIABLES                                                     |
    // +-----------------------------------------------------------------------+
    private
        $attributes = null;
    // +-----------------------------------------------------------------------+
    // | METHODS                                                               |
    // +-----------------------------------------------------------------------+
    /**
     * Clear all attributes associated with this user.
     *
     * @return void
     */
    public function clearAttributes ()
    {
        $this->attributes = null;
        $this->attributes = array();
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve an attribute.
     *
     * @param string An attribute name.
     * @param string An attribute namespace.
     *
     * @return mixed An attribute value, if the attribute exists, otherwise
     *               null.
     */
    public function & getAttribute ($name, $ns = MO_USER_NAMESPACE)
    {
        $retval = null;
        if (isset($this->attributes[$ns]) &&
            isset($this->attributes[$ns][$name]))
        {
            return $this->attributes[$ns][$name];
        }
        return $retval;
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve an array of attribute names.
     *
     * @param string An attribute namespace.
     *
     * @return array An indexed array of attribute names, if the namespace
     *               exists, otherwise null.
     */
    public function getAttributeNames ($ns = MO_USER_NAMESPACE)
    {
        if (isset($this->attributes[$ns]))
        {
            return array_keys($this->attributes[$ns]);
        }
        return null;
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve all attributes within a namespace.
     *
     * @param string An attribute namespace.
     *
     * @return array An associative array of attributes.
     */
    public function & getAttributeNamespace ($ns = MO_USER_NAMESPACE)
    {
        $retval = null;
        if (isset($this->attributes[$ns]))
        {
            return $this->attributes[$ns];
        }
        return $retval;
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve an array of attribute namespaces.
     *
     * @return array An indexed array of attribute namespaces.
     */
    public function getAttributeNamespaces ()
    {
        return array_keys($this->attributes);
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve the current application context.
     *
     * @return Context A Context instance.
     */
    public function getContext ()
    {
        return Controller::getInstance()->getContext();
    }
    // -------------------------------------------------------------------------
    /**
     * Indicates whether or not an attribute exists.
     *
     * @param string An attribute name.
     * @param string An attribute namespace.
     *
     * @return bool true, if the attribute exists, otherwise false.
     */
    public function hasAttribute ($name, $ns = MO_USER_NAMESPACE)
    {
        if (isset($this->attributes[$ns]))
        {
            return isset($this->attributes[$ns][$name]);
        }
        return false;
    }
    // -------------------------------------------------------------------------
    /**
     * Indicates whether or not an attribute namespace exists.
     *
     * @param string An attribute namespace.
     *
     * @return bool true, if the namespace exists, otherwise false.
     */
    public function hasAttributeNamespace ($ns)
    {
        return isset($this->attributes[$ns]);
    }
    // -------------------------------------------------------------------------
    /**
     * Initialize this User.
     *
     * @param Context A Context instance.
     * @param array   An associative array of initialization parameters.
     *
     * @return bool true, if initialization completes successfully, otherwise
     *              false.
     *
     * @throws <b>InitializationException</b> If an error occurs while
     *                                        initializing this User.
     */
    public function initialize ($context, $parameters = null)
    {
        if ($parameters != null)
        {
            $this->parameters = array_merge($this->parameters, $parameters);
        }
        // read data from storage
        $this->attributes = $this->getContext()
                                 ->getStorage()
                                 ->read(self::ATTRIBUTE_NAMESPACE);
        if ($this->attributes == null)
        {
            // initialize our attributes array
            $this->attributes = array();
        }
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve a new User implementation instance.
     *
     * @param string A User implementation name
     *
     * @return User A User implementation instance.
     *
     * @throws <b>FactoryException</b> If a user implementation instance cannot
     *                                 be created.
     */
    public static function newInstance ($class)
    {
        // the class exists
        $object = new $class();
        if (!($object instanceof User))
        {
            // the class name is of the wrong type
            $error = 'Class "%s" is not of the type User';
            $error = sprintf($error, $class);
            throw new FactoryException($error);
        }
        return $object;
    }
    // -------------------------------------------------------------------------
    /**
     * Remove an attribute.
     *
     * @param string An attribute name.
     * @param string An attribute namespace.
     *
     * @return mixed An attribute value, if the attribute was removed,
     *               otherwise null.
     */
    public function & removeAttribute ($name, $ns = MO_USER_NAMESPACE)
    {
        $retval = null;
        if (isset($this->attributes[$ns]) &&
            isset($this->attributes[$ns][$name]))
        {
            $retval =& $this->attributes[$ns][$name];
            unset($this->attributes[$ns][$name]);
        }
        return $retval;
    }
    // -------------------------------------------------------------------------
    /**
     * Remove an attribute namespace and all of its associated attributes.
     *
     * @param string An attribute namespace.
     *
     * @return void
     */
    public function removeAttributeNamespace ($ns)
    {
        if (isset($this->attributes[$ns]))
        {
            unset($this->attributes[$ns]);
        }
    }
    // -------------------------------------------------------------------------
    /**
     * Set an attribute.
     *
     * If an attribute with the name already exists the value will be
     * overridden.
     *
     * @param string An attribute name.
     * @param mixed  An attribute value.
     * @param string An attribute namespace.
     *
     * @return void
     */
    public function setAttribute ($name, $value, $ns = MO_USER_NAMESPACE)
    {
        if (!isset($this->attributes[$ns]))
        {
            $this->attributes[$ns] = array();
        }
        $this->attributes[$ns][$name] = $value;
    }
    // -------------------------------------------------------------------------
    /**
     * Set an attribute by reference.
     *
     * If an attribute with the name already exists the value will be
     * overridden.
     *
     * @param string An attribute name.
     * @param mixed  A reference to an attribute value.
     * @param string An attribute namespace.
     *
     * @return void
     */
    public function setAttributeByRef ($name, &$value, $ns = MO_USER_NAMESPACE)
    {
        if (!isset($this->attributes[$ns]))
        {
            $this->attributes[$ns] = array();
        }
        $this->attributes[$ns][$name] =& $value;
    }
    // -------------------------------------------------------------------------
    /**
     * Set an array of attributes.
     *
     * If an existing attribute name matches any of the keys in the supplied
     * array, the associated value will be overridden.
     *
     * @param array  An associative array of attributes and their associated
     *               values.
     * @param string An attribute namespace.
     *
     * @return void
     */
    public function setAttributes ($attributes, $ns = MO_USER_NAMESPACE)
    {
        if (!isset($this->attributes[$ns]))
        {
            $this->attributes[$ns] = array();
        }
        $this->attributes[$ns] = array_merge($this->attributes[$ns],
                                             $attributes);
    }
    // -------------------------------------------------------------------------
    /**
     * Set an array of attributes by reference.
     *
     * If an existing attribute name matches any of the keys in the supplied
     * array, the associated value will be overridden.
     *
     * @param array  An associative array of attributes and references to their
     *               associated values.
     * @param string An attribute namespace.
     *
     * @return void
     */
    public function setAttributesByRef (&$attributes, $ns = MO_USER_NAMESPACE)
    {
        if (!isset($this->attributes[$ns]))
        {
            $this->attributes[$ns] = array();
        }
        foreach ($attributes as $key => &$value)
        {
            $this->attributes[$ns][$key] =& $value;
        }
    }
    // -------------------------------------------------------------------------
    /**
     * Execute the shutdown procedure.
     *
     * @return void
     */
    public function shutdown ()
    {
        // write attributes to the storage
        $this->getContext()
             ->getStorage()
             ->write(self::ATTRIBUTE_NAMESPACE, $this->attributes);
    }
}
namespace Mojavi\Validator;
use Mojavi\Controller\Controller as Controller;
/**
 * Validator allows you to apply constraints to user entered parameters.
 */
abstract class Validator extends \Mojavi\Util\ParameterHolder
{
    // +-----------------------------------------------------------------------+
    // | PRIVATE VARIABLES                                                     |
    // +-----------------------------------------------------------------------+
    // +-----------------------------------------------------------------------+
    // | METHODS                                                               |
    // +-----------------------------------------------------------------------+
    /**
     * Execute this validator.
     *
     * @param mixed A file or parameter value/array.
     * @param string An error message reference.
     *
     * @return bool true, if this validator executes successfully, otherwise
     *              false.
     */
    abstract function execute (&$value, &$error);
    // -------------------------------------------------------------------------
    /**
     * Retrieve the current application context.
     *
     * @return Context The current Context instance.
     */
    public function getContext ()
    {
        return Controller::getInstance()->getContext();
    }
    // -------------------------------------------------------------------------
    /**
     * Initialize this validator.
     *
     * @param Context The current application context.
     * @param array   An associative array of initialization parameters.
     *
     * @return bool true, if initialization completes successfully, otherwise
     *              false.
     */
    public function initialize ($context, $parameters = null)
    {
        if ($parameters != null)
        {
            $this->parameters = array_merge($this->parameters, $parameters);
        }
        return true;
    }
}
namespace Mojavi\Validator;
use Mojavi\Core\MojaviObject as MojaviObject;
/**
 * ValidatorManager provides management for request parameters and their
 * associated validators.
 */
class ValidatorManager extends MojaviObject
{
    // +-----------------------------------------------------------------------+
    // | PRIVATE VARIABLES                                                     |
    // +-----------------------------------------------------------------------+
    private
        $groups  = array(),
        $names   = array(),
        $request = null;
    // +-----------------------------------------------------------------------+
    // | METHODS                                                               |
    // +-----------------------------------------------------------------------+
    /**
     * Clear this validator manager so it can be reused.
     *
     * @retun void
     */
    public function clear ()
    {
        $this->groups = null;
        $this->groups = array();
        $this->names  = null;
        $this->names  = array();
    }
    // -------------------------------------------------------------------------
    /**
     * Execute all validators and determine the validation status.
     *
     * @return bool true, if validation completed successfully, otherwise false.
     */
    public function execute ()
    {
        $retval = true;
        // loop through the names and start our validation
        // if 1 or more groups exist, we'll have to do a second pass
        $pass = 1;
        while (true)
        {
            foreach ($this->names as $name => &$data)
            {
                if (isset($data['_is_parent']))
                {
                    // this is a parent
                    foreach ($data as $subname => &$subdata)
                    {
                        if ($subname == '_is_parent')
                        {
                            // this isn't an actual index, but more of a flag
                            continue;
                        }
                        if ($subdata['validation_status'] == true &&
                            !$this->validate($subname, $subdata, $name))
                        {
                            // validation failed
                            $retval = false;
                        }
                    }
                } else
                {
                    // single parameter
                    if ($data['validation_status'] == true &&
                        !$this->validate($name, $data, null))
                    {
                        // validation failed
                        $retval = false;
                    }
                }
            }
            if (count($this->groups) == 0 || $pass == 2)
            {
                break;
            }
            // increase our pass indicator
            $pass++;
        }
        return $retval;
    }
    // -------------------------------------------------------------------------
    /**
     * Initialize this validator manager.
     *
     * @param Context A context instance.
     *
     * @return void
     */
    public function initialize ($context)
    {
        $this->request = $context->getRequest();
    }
    // -------------------------------------------------------------------------
    /**
     * Register a file or parameter.
     *
     * @param string  A file or parameter name.
     * @param bool    The required status.
     * @param string  A required error message.
     * @param string  A group name.
     * @param string  A parent array.
     */
    public function registerName ($name, $required = true,
                                  $message = 'Required', $parent = null,
                                  $group = null, $isFile = false)
    {
        // create the entry
        $entry                      = array();
        $entry['group']             = null;
        $entry['is_file']           = $isFile;
        $entry['required']          = $required;
        $entry['required_msg']      = $message;
        $entry['validation_status'] = true;
        $entry['validators']        = array();
        if ($parent != null)
        {
            // this parameter has a parent array
            if (!isset($this->names[$parent]))
            {
                // create the parent array
                $this->names[$parent] = array('_is_parent' => true);
            }
            // register this parameter
            $this->names[$parent][$name] =& $entry;
        } else
        {
            // no parent
            // register this parameter
            $this->names[$name] =& $entry;
        }
        if ($group != null)
        {
            // set group
            if (!isset($this->groups[$group]))
            {
                // create our group
                $this->groups[$group] = array('_force' => false);
            }
            // add this file/parameter name to the group
            $this->groups[$group][] = $name;
            // add a reference back to the group array to the file/param array
            $entry['group'] =& $this->groups[$group];
        }
    }
    // -------------------------------------------------------------------------
    /**
     * Register a validator for a file or parameter.
     *
     * @param string    A file or parameter name.
     * @param Validator A validator implementation instance.
     * @param string    A parent array name.
     *
     * @return void
     */
    public function registerValidator ($name, $validator, $parent = null)
    {
        if ($parent != null)
        {
            // this parameter has a parent
            $this->names[$parent][$name]['validators'][] = $validator;
        } else
        {
            // no parent
            $this->names[$name]['validators'][] = $validator;
        }
    }
    // -------------------------------------------------------------------------
    /**
     * Validate a file or parameter.
     *
     * @param string A file or parameter name.
     * @param array  Data associated with the file or parameter.
     * @param string A parent name.
     *
     * @return bool true, if validation completes successfully, otherwise false.
     */
    private function validate (&$name, &$data, $parent)
    {
        // get defaults
        $error     = null;
        $errorName = null;
        $force     = ($data['group'] != null) ? $data['group']['_force'] : true;
        $retval    = true;
        $value     = null;
        // get our parameter value
        if ($parent == null)
        {
            // normal file/parameter
            $errorName = $name;
            if ($data['is_file'])
            {
                // file
                $value =& $this->request->getFile($name);
            } else
            {
                // parameter
                $value =& $this->request->getParameter($name);
            }
        } else
        {
            // we have a parent
            $errorName = $parent . '{' . $name . '}';
            if ($data['is_file'])
            {
                // file
                $parent =& $this->request->getFile($parent);
            } else
            {
                // parameter
                $parent =& $this->request->getParameter($parent);
            }
            if ($parent != null && isset($parent[$name]))
            {
                $value =& $parent[$name];
            }
        }
        // now for the dirty work
        if ($value == null || strlen($value) == 0)
        {
            if (!$data['required'] || !$force)
            {
                // we don't have to validate it
                $retval = true;
            } else
            {
                // it's empty!
                $error  = $data['required_msg'];
                $retval = false;
            }
        } else
        {
            // time for the fun
            $error = null;
            // get group force status
            if ($data['group'] != null)
            {
                // we set this because we do have a value for a parameter in
                // this group
                $data['group']['_force'] = true;
                $force                   = true;
            }
            if (count($data['validators']) > 0)
            {
                // loop through our validators
                foreach ($data['validators'] as $validator)
                {
                    if (!$validator->execute($value, $error))
                    {
                        $retval = false;
                    }
                }
            }
        }
        if (!$retval)
        {
            // set validation status
            $data['validation_status'] = false;
            // set the request error
            $this->request->setError($errorName, $error);
        }
        return $retval;
    }
}
/**
 * A view represents the presentation layer of an action. Output can be
 * customized by supplying attributes, which a template can manipulate and
 * display.
 *
 * @package    Mojavi
 * @subpackage View
 */
namespace Mojavi\View;
use Mojavi\Core\MojaviObject as MojaviObject;
use Mojavi\Controller\Controller as Controller;
use Mojavi\Exception\RenderException as RenderException;
use Mojavi\Util\Toolkit as Toolkit;
abstract class View extends MojaviObject
{
    // +-----------------------------------------------------------------------+
    // | CONSTANTS                                                             |
    // +-----------------------------------------------------------------------+
    /**
     * Show an alert view.
     *
     * @since 3.0.0
     */
    const ALERT = 'Alert';
    /**
     * Show an error view.
     *
     * @since 3.0.0
     */
    const ERROR = 'Error';
    /**
     * Show a form input view.
     *
     * @since 3.0.0
     */
    const INPUT = 'Input';
    /**
     * Skip view execution.
     *
     * @since 3.0.0
     */
    const NONE = null;
    /**
     * Show a success view.
     *
     * @since 3.0.0
     */
    const SUCCESS = 'Success';
    /**
     * Render the presentation to the client.
     *
     * @since 3.0.0
     */
    const RENDER_CLIENT = 2;
    /**
     * Do not render the presentation.
     *
     * @since 3.0.0
     */
    const RENDER_NONE = 1;
    /**
     * Render the presentation to a variable.
     *
     * @since 3.0.0
     */
    const RENDER_VAR = 4;
    // +-----------------------------------------------------------------------+
    // | PRIVATE VARIABLES                                                     |
    // +-----------------------------------------------------------------------+
    private
        $decorator          = false,
        $decoratorDirectory = null,
        $decoratorTemplate  = null,
        $directory          = null,
        $slots              = array(),
        $template           = null;
    // +-----------------------------------------------------------------------+
    // | METHODS                                                               |
    // +-----------------------------------------------------------------------+
    /**
     * Clear all attributes associated with this view.
     *
     * @return void
     */
    abstract function clearAttributes ();
    // -------------------------------------------------------------------------
    /**
     * Loop through all template slots and fill them in with the results of
     * presentation data.
     *
     * @param string A chunk of decorator content.
     *
     * @return string A decorated template.
     */
    protected function & decorate (&$content)
    {
        // alias controller
        $controller = $this->getContext()->getController();
        // get original render mode
        $renderMode = $controller->getRenderMode();
        // set render mode to var
        $controller->setRenderMode(self::RENDER_VAR);
        // grab the action stack
        $actionStack = $controller->getActionStack();
        // loop through our slots, and replace them one-by-one in the
        // decorator template
        $slots =& $this->getSlots();
        foreach ($slots as $name => &$slot)
        {
            // grab this next forward's action stack index
            $index = $actionStack->getSize();
            // forward to the first slot action
            $controller->forward($slot['module_name'], $slot['action_name']);
            // grab the action entry from this forward
            $actionEntry = $actionStack->getEntry($index);
            // set the presentation data as a template attribute
            $presentation =& $actionEntry->getPresentation();
            $this->setAttributeByRef($name, $presentation);
        }
        // put render mode back
        $controller->setRenderMode($renderMode);
        // set the decorator content as an attribute
        $this->setAttributeByRef('content', $content);
        // return a null value to satisfy the requirement
        $retval = null;
        return $retval;
    }
    // -------------------------------------------------------------------------
    /**
     * Execute any presentation logic and set template attributes.
     *
     * @return void
     */
    abstract function execute ();
    // -------------------------------------------------------------------------
    /**
     * Retrieve an attribute.
     *
     * @param string An attribute name.
     *
     * @return mixed An attribute value, if the attribute exists, otherwise
     *               null.
     */
    abstract function & getAttribute ($name);
    // -------------------------------------------------------------------------
    /**
     * Retrieve an array of attribute names.
     *
     * @return array An indexed array of attribute names.
     */
    abstract function getAttributeNames ();
    // -------------------------------------------------------------------------
    /**
     * Retrieve the current application context.
     *
     * @return \Mojavi\Core\Context The current Context instance.
     */
    public function getContext ()
    {
        return Controller::getInstance()->getContext();
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve this views decorator template directory.
     *
     * @return string An absolute filesystem path to this views decorator
     *                template directory.
     */
    public function getDecoratorDirectory ()
    {
        return $this->decoratorDirectory;
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve this views decorator template.
     *
     * @return string A template filename, if a template has been set, otherwise
     *                null.
     */
    public function getDecoratorTemplate ()
    {
        return $this->decoratorTemplate;
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve this views template directory.
     *
     * @return string An absolute filesystem path to this views template
     *                directory.
     */
    public function getDirectory ()
    {
        return $this->directory;
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve the template engine associated with this view.
     *
     * Note: This will return null for PHPView instances.
     *
     * @return mixed A template engine instance.
     */
    abstract function & getEngine ();
    // -------------------------------------------------------------------------
    /**
     * Retrieve an array of specified slots for the decorator template.
     *
     * @return array An associative array of decorator slots.
     */
    protected function & getSlots ()
    {
        return $this->slots;
    }
    // -------------------------------------------------------------------------
    /**
     * Retrieve this views template.
     *
     * @return string A template filename, if a template has been set, otherwise
     *                null.
     */
    public function getTemplate ()
    {
        return $this->template;
    }
    // -------------------------------------------------------------------------
    /**
     * Import parameter values and error messages from the request directly as
     * view attributes.
     *
     * @param array An indexed array of file/parameter names.
     * @param bool  Is this a list of files?
     * @param bool  Import error messages too?
     * @param bool  Run strip_tags() on attribute value?
     * @param bool  Run htmlspecialchars() on attribute value?
     *
     * @return void
     */
    public function importAttributes ($names, $files = false, $errors = true, $stripTags = true, $specialChars = true)
    {
        // alias $request to keep the code clean
        $request = $this->getContext()->getRequest();
        // get our array
        if ($files) {
            // file names
            $array =& $request->getFiles();
        } else {
            // parameter names
            $array =& $request->getParameters();
        }
        // loop through our parameter names and import them
        foreach ($names as &$name)
        {
            if (preg_match('/^([a-z0-9\-_]+)\{([a-z0-9\s\-_]+)\}$/i', $name, $match)) {
                // we have a parent
                $parent  = $match[1];
                $subname = $match[2];
                // load the file/parameter value for this attribute if one
                // exists
                if (isset($array[$parent]) && isset($array[$parent][$subname]))  {
                    $value = $array[$parent][$subname];
                    if ($stripTags) {
                        $value = strip_tags($value);
                    }
                    if ($specialChars) {
                        $value = htmlspecialchars($value);
                    }
                    $this->setAttribute($name, $value);
                } else
                {
                    // set an empty value
                    $this->setAttribute($name, '');
                }
            } else {
                // load the file/parameter value for this attribute if one
                // exists
                if (isset($array[$name])) {
                    $value = $array[$name];
                    if ($stripTags) {
                        $value = strip_tags($value);
                    }
                    if ($specialChars) {
                        $value = htmlspecialchars($value);
                    }
                    $this->setAttribute($name, $value);
                } else {
                    // set an empty value
                    $this->setAttribute($name, '');
                }
            }
            if ($errors) {
                if ($request->hasError($name)) {
                    $this->setAttribute($name . '_error',
                                        $request->getError($name));
                } else {
                    // set empty error
                    $this->setAttribute($name . '_error', '');
                }
            }
        }
    }
    // -------------------------------------------------------------------------
    /**
     * Initialize this view.
     *
     * @param Context The current application context.
     *
     * @return bool true, if initialization completes successfully, otherwise
     *              false.
     */
    public function initialize ($context)
    {
        // set the currently executing module's template directory as the
        // default template directory
        $module = $context->getModuleName();
        $class_name = get_class($this);
        $class_name = str_replace('View', '', $class_name);
        $this->template                = $class_name . ".php";
        $this->decoratorDirectory = MO_MODULE_DIR . '/' . $module .'/templates';
        $this->directory          = $this->decoratorDirectory;
        return true;
    }
    // -------------------------------------------------------------------------
    /**
     * Indicates that this view is a decorating view.
     *
     * @return bool true, if this view is a decorating view, otherwise false.
     */
    public function isDecorator ()
    {
        return $this->decorator;
    }
    // -------------------------------------------------------------------------
    /**
     * Execute a basic pre-render check to verify all required variables exist
     * and that the template is readable.
     *
     * @return void
     *
     * @throws <b>RenderException</b> If the pre-render check fails.
     */
    protected function preRenderCheck ()
    {
        if ($this->template == null) {
            // a template has not been set
            $error = 'A template has not been set';
            throw new RenderException($error);
        }
        $template = $this->directory . '/' . $this->template;
        if (!is_readable($template)) {
            // the template isn't readable
            $error = 'The template "%s" does not exist or is unreadable';
            $error = sprintf($error, $template);
            throw new RenderException($error);
        }
        // check to see if this is a decorator template
        if ($this->decorator) {
            $template = $this->decoratorDirectory . '/' . $this->decoratorTemplate;
            if (!is_readable($template)) {
                // the decorator template isn't readable
                $error = 'The decorator template "%s" does not exist or is ' .
                         'unreadable';
                $error = sprintf($error, $template);
                throw new RenderException($error);
            }
        }
    }
    // -------------------------------------------------------------------------
    /**
     * Remove an attribute.
     *
     * @param string An attribute name.
     *
     * @return mixed An attribute value, if the attribute was removed,
     *               otherwise null.
     */
    abstract function & removeAttribute ($name);
    // -------------------------------------------------------------------------
    /**
     * Render the presentation.
     *
     * When the controller render mode is View::RENDER_CLIENT, this method will
     * render the presentation directly to the client and null will be returned.
     *
     * @return string A string representing the rendered presentation, if
     *                the controller render mode is View::RENDER_VAR, otherwise
     *                null.
     */
    abstract function & render ();
    // -------------------------------------------------------------------------
    /**
     * Set an attribute.
     *
     * @param string An attribute name.
     * @param mixed  An attribute value.
     *
     * @return void
     */
    abstract function setAttribute ($name, $value);
    // -------------------------------------------------------------------------
    /**
     * Set an attribute by reference.
     *
     * @param string An attribute name.
     * @param mixed  A reference to an attribute value.
     *
     * @return void
     */
    abstract function setAttributeByRef ($name, &$value);
    // -------------------------------------------------------------------------
    /**
     * Set an array of attributes.
     *
     * @param array An associative array of attributes and their associated
     *              values.
     *
     * @return void
     */
    abstract function setAttributes ($values);
    // -------------------------------------------------------------------------
    /**
     * Set an array of attributes by reference.
     *
     * @param array An associative array of attributes and references to their
     *              associated values.
     *
     * @return void
     */
    abstract function setAttributesByRef (&$values);
    // -------------------------------------------------------------------------
    /**
     * Set the decorator template directory for this view.
     *
     * @param string An absolute filesystem path to a template directory.
     *
     * @return void
     */
    public function setDecoratorDirectory ($directory)
    {
        $this->decoratorDirectory = $directory;
    }
    // -------------------------------------------------------------------------
    /**
     * Set the decorator template for this view.
     *
     * If the template path is relative, it will be based on the currently
     * executing module's template sub-directory.
     *
     * @param string An absolute or relative filesystem path to a template.
     *
     * @return void
     */
    public function setDecoratorTemplate ($template)
    {
        if (Toolkit::isPathAbsolute($template)) {
            $this->decoratorDirectory = dirname($template);
            $this->decoratorTemplate  = basename($template);
        } else {
            $this->decoratorTemplate = $template;
        }
        // set decorator status
        $this->decorator = true;
    }
    // -------------------------------------------------------------------------
    /**
     * Set the template directory for this view.
     *
     * @param string An absolute filesystem path to a template directory.
     *
     * @return void
     */
    public function setDirectory ($directory)
    {
        $this->directory = $directory;
    }
    // -------------------------------------------------------------------------
    /**
     * Set the module and action to be executed in place of a particular
     * template attribute.
     *
     * If a slot with the name already exists, it will be overridden.
     *
     * @param string A template attribute name.
     * @param string A module name.
     * @param string An action name.
     *
     * @return void
     */
    public function setSlot ($attributeName, $moduleName, $actionName)
    {
        $this->slots[$attributeName]                = array();
        $this->slots[$attributeName]['module_name'] = $moduleName;
        $this->slots[$attributeName]['action_name'] = $actionName;
    }
    // -------------------------------------------------------------------------
    /**
     * Set the template for this view.
     *
     * If the template path is relative, it will be based on the currently
     * executing module's template sub-directory.
     *
     * @param string An absolute or relative filesystem path to a template.
     *
     * @return void
     */
    public function setTemplate ($template)
    {
        if (Toolkit::isPathAbsolute($template)) {
            $this->directory = dirname($template);
            $this->template  = basename($template);
        } else {
            $this->template = $template;
        }
    }
}
?>